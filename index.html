<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OR-ToolKit</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 20px; max-width: 1100px; margin: auto; background-color: #f9f9f9; color: #333; }
        h1, h2, h3 { color: #333; text-align: center; }
        
        /* --- New Selector Styling --- */
        .selector-container {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            border-top: 4px solid #007bff;
        }
        .selector-label {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
            color: #555;
        }
        select#tool-menu {
            padding: 12px 20px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 5px;
            width: 100%;
            max-width: 400px;
            cursor: pointer;
            outline: none;
            transition: border-color 0.3s;
        }
        select#tool-menu:focus {
            border-color: #007bff;
        }

        /* --- Tool Containers --- */
        .tool-content { display: none; padding: 20px; border: 1px solid #ccc; background: white; border-radius: 5px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); animation: fadeIn 0.5s; }
        .tool-content.active { display: block; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Existing Styles (Kept for compatibility) --- */
        .config-section, .input-section { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .input-row { display: flex; align-items: center; margin-bottom: 10px; flex-wrap: wrap; justify-content: center; }
        input[type="number"], input[type="text"] { width: 60px; padding: 5px; margin: 0 5px; border: 1px solid #ccc; border-radius: 4px; text-align: center; }
        
        button { background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-top: 10px; }
        button:hover { background-color: #0056b3; }

        table { border-collapse: collapse; width: 100%; margin: 15px 0; font-size: 14px; background: white; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        
        /* LP Styles */
        .lp-pivot-col { background-color: #e6f7ff; }
        .lp-pivot-row { background-color: #fff0f0; }
        .lp-pivot-element { background-color: #ffeb3b; font-weight: bold; border: 2px solid #ff9800; }
        .lp-optimal-res { color: green; font-weight: bold; font-size: 1.2em; }
        
        /* OR Styles */
        .or-table { border: none; }
        .or-table th { background-color: white; color: #333; font-weight: bold; border: none; border-bottom: 2px solid #00bcd4; padding: 10px; }
        .or-table td { border: none; border-bottom: 1px solid #eee; padding: 10px; }
        .or-table .top-cj-row th { border-bottom: none; color: #333; font-weight: bold; }
        .or-table .header-row th { color: #555; border-top: 2px solid #00bcd4; border-bottom: 2px solid #00bcd4; background-color: #e0f7fa; }
        
        .or-pivot-col { background-color: #e3f2fd; }
        .or-pivot-row { background-color: #fff3e0; }
        .or-pivot-element { background-color: #ffe082; font-weight: bold; border: 1px solid #ffca28; }
        
        .or-bottom-row td { font-weight: bold; border-top: 2px solid #00bcd4; color: #555; }
        .or-zj-label, .or-cjzj-label { font-style: italic; color: #0097a7; }

        .or-iter-info { background-color: #eef2ff; padding: 10px; border-radius: 5px; border-left: 4px solid #6366f1; margin-bottom: 10px; font-weight: 500; }
        
        .standard-form-box { background-color: #fff; padding: 20px; border-radius: 8px; border: 1px solid #e0e0e0; margin-bottom: 25px; font-family: "Times New Roman", Times, serif; font-size: 1.1em; line-height: 1.6; }

        .iteration-box { border: 1px solid #ccc; padding: 15px; margin-bottom: 20px; background: white; }

        .contact-footer { text-align: center; margin-top: 40px; margin-bottom: 20px; padding: 10px; }
        .contact-footer p { margin: 0 0 5px 0; font-size: 14px; color: #666; font-weight: 600; }
        .contact-footer img { width: 45px; height: auto; transition: transform 0.2s ease; display: inline-block; }
        .contact-footer img:hover { transform: scale(1.1); opacity: 0.9; }

        .stats-box { position: fixed; bottom: 10px; left: 10px; background: rgba(255, 255, 255, 0.95); padding: 8px 12px; border: 1px solid #ccc; border-radius: 5px; font-family: sans-serif; font-size: 13px; z-index: 1000; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    </style>
</head>
<body>

    <div style="text-align: center; margin: 20px 0;">
        <img src="https://i.ibb.co/C3KMKT9N/photo-2023-07-08-02-41-40-2.jpg" alt="Simplex Logo" style="max-width: 100%; max-height: 250px; height: auto; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
    </div>

    <!-- UPDATED HEADER -->
    <h1>The شنطة العدة of Operations Research</h1>

    <!-- NEW TOOL SELECTOR -->
    <div class="selector-container">
        <label class="selector-label" for="tool-menu">إيه اللي جابك؟</label>
        <select id="tool-menu" onchange="switchTool()">
            <option value="" disabled selected>Select a tool from the list...</option>
            <!-- Alphabetical Order -->
            <option value="lp-simplex">[LP] Simplex Solver full steps</option>
            <option value="or-forecasting">[OR] Forecasting Calc full steps</option>
            <option value="or-simplex">[OR] Simplex Solver full steps</option>
        </select>
    </div>

    <!-- ========================================== -->
    <!-- TOOL 1: LP Simplex (Existing)             -->
    <!-- ========================================== -->
    <div id="lp-simplex" class="tool-content">
        <h2 style="border-bottom: 2px solid #007bff; padding-bottom: 10px;">[LP] Simplex Solver</h2>
        <div class="config-section">
            <h3>Configuration</h3>
            <label>Variables: <input type="number" id="lp_numVars" value="2" min="1"></label>
            <label>Constraints: <input type="number" id="lp_numConstraints" value="2" min="1"></label>
            <button onclick="generateLPInputs()">Generate Inputs</button>
        </div>

        <div id="lp-matrix-inputs" class="input-section" style="display:none;">
            <h3>Objective Function (Max Z)</h3>
            <div id="lp-obj-inputs" class="input-row"></div>
            <h3>Constraints (<=)</h3>
            <div id="lp-constraint-inputs"></div>
            <button onclick="solveLP()">Solve</button>
        </div>

        <div id="lp-output-area"></div>
    </div>

    <!-- ========================================== -->
    <!-- TOOL 2: OR Forecasting (Placeholder)      -->
    <!-- ========================================== -->
  <div id="or-forecasting" class="tool-content">
        <h2 style="border-bottom: 2px solid #28a745; padding-bottom: 10px; color: #28a745;">[OR] Forecasting Calculator</h2>
        
        <div class="config-section">
            <h3>1. Configuration</h3>
            
            <div class="input-row">
                <label>Number of Periods (Rows): <input type="number" id="fc_numPeriods" value="5" min="2"></label>
            </div>
            
            <!-- Time Unit Selection -->
            <div class="input-row" style="background: #f1f8ff; padding: 10px; border-radius: 5px;">
                <span style="font-weight: bold; margin-right: 10px;">Time Labels:</span>
                
                <label style="margin-right: 15px;">
                    <input type="radio" name="fc_timeUnit" value="generic" checked onclick="toggleDateInput()"> 
                    Generic (1, 2, 3...)
                </label>
                
                <label style="margin-right: 15px;">
                    <input type="radio" name="fc_timeUnit" value="years" onclick="toggleDateInput()"> 
                    Years
                </label>
                
                <label>
                    <input type="radio" name="fc_timeUnit" value="months" onclick="toggleDateInput()"> 
                    Months
                </label>
                
                <!-- Dynamic Start Input -->
                <span id="fc_start_year_span" style="display:none; margin-left: 10px;">
                    Start Year: <input type="number" id="fc_startYear" value="2020" style="width: 70px;">
                </span>

                <span id="fc_start_month_span" style="display:none; margin-left: 10px;">
                    Start Month: 
                    <select id="fc_startMonth" style="padding: 5px;">
                        <option value="0">January</option>
                        <option value="1">February</option>
                        <option value="2">March</option>
                        <option value="3">April</option>
                        <option value="4">May</option>
                        <option value="5">June</option>
                        <option value="6">July</option>
                        <option value="7">August</option>
                        <option value="8">September</option>
                        <option value="9">October</option>
                        <option value="10">November</option>
                        <option value="11">December</option>
                    </select>
                </span>
            </div>

            <!-- Seasonal Option -->
            <div class="input-row" style="margin-top: 10px; border-top: 1px dashed #ccc; padding-top: 10px;">
                <label style="margin-right: 15px;">
                    <input type="checkbox" id="fc_isSeasonal" onchange="toggleSeasonalInput()"> 
                    <strong>Seasonal Data?</strong>
                </label>
                <span id="fc_season_config" style="display:none;">
                    Number of Seasons (Parts): <input type="number" id="fc_seasonParts" value="4" min="2" style="width: 50px;">
                </span>
            </div>
            
            <button onclick="generateForecastingTable()" style="background-color: #28a745;">Generate Table</button>
        </div>

        <div id="fc-data-section" class="input-section" style="display:none;">
            <h3>2. Data Entry</h3>
            
            <!-- Output Format Option -->
            <div style="text-align:center; margin-bottom: 10px; padding: 5px; background: #eee; border-radius: 4px;">
                <strong>Output Format:</strong> 
                <label style="margin-left: 10px;"><input type="checkbox" id="fc_use_frac"> Show as Fractions</label>
                <span style="font-size: 0.9em; color: #666; margin-left: 10px;">(Unchecked = Decimals .00)</span>
            </div>

            <div style="margin-bottom: 15px; text-align: center;">
                <label>Column Name (X): <input type="text" id="fc_header_x" value="Period" style="width: 100px;"></label>
                <label>Column Name (Y): <input type="text" id="fc_header_y" value="Demand" style="width: 100px;"></label>
            </div>

            <div id="fc-table-container" style="overflow-x: auto; margin-bottom: 20px;"></div>

            <!-- Methods Selection -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; border: 1px solid #ddd; margin-bottom: 15px;">
                <h4 style="margin-top: 0;">3. Choose Methods</h4>
                <label style="display:block; margin-bottom:5px; border-bottom:1px solid #eee;">
                    <input type="checkbox" onchange="toggleAllFC(this, 'fc_method')"> Select All Methods
                </label>
                <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                    <label><input type="checkbox" class="fc_method" value="MA"> Moving Average (MA)</label>
                    <label><input type="checkbox" class="fc_method" value="WMA"> Weighted MA</label>
                    <label><input type="checkbox" class="fc_method" value="SES"> Simple Exp. Smoothing</label>
                    <label><input type="checkbox" class="fc_method" value="AES"> Adjusted Exp. Smoothing</label>
                    <label><input type="checkbox" class="fc_method" value="LTL"> Linear Trend Line</label>
                    <label><input type="checkbox" class="fc_method" value="SA" id="fc_method_sa" disabled> Seasonal Adjustments</label>
                </div>
            </div>

            <!-- Accuracy Selection -->
            <div style="background: #fff3cd; padding: 15px; border-radius: 5px; border: 1px solid #ffeeba;">
                <h4 style="margin-top: 0;">4. Accuracy Measures (Detailed Tables)</h4>
                <label style="display:block; margin-bottom:5px; border-bottom:1px solid #faeacc;">
                    <input type="checkbox" onchange="toggleAllFC(this, 'fc_acc')"> Select All Measures
                </label>
                <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                    <label><input type="checkbox" class="fc_acc" value="MAD"> MAD (Abs Deviation)</label>
                    <label><input type="checkbox" class="fc_acc" value="MAPD"> MAPD/MAPE (%)</label>
                    <label><input type="checkbox" class="fc_acc" value="E"> Cumulative Error (E)</label>
                    <label><input type="checkbox" class="fc_acc" value="EBAR"> Average Error (Bias)</label>
                </div>
            </div>

            <button onclick="solveForecasting()" style="background-color: #28a745; width: 100%; font-size: 18px;">Calculate Forecasts</button>
        </div>

        <div id="fc-output-area"></div>
    </div>

    <!-- ========================================== -->
    <!-- TOOL 3: OR Simplex (Existing)             -->
    <!-- ========================================== -->
    <div id="or-simplex" class="tool-content">
        <h2 style="border-bottom: 2px solid #00bcd4; padding-bottom: 10px;">[OR] Simplex Solver</h2>
        <div class="config-section">
            <h3>Configuration</h3>
            <label>Variables: <input type="number" id="or_numVars" value="2" min="1"></label>
            <label>Constraints: <input type="number" id="or_numConstraints" value="2" min="1"></label>
            <button onclick="generateORInputs()">Generate Inputs</button>
        </div>

        <div id="or-matrix-inputs" class="input-section" style="display:none;">
            <h3>Objective Function (Maximize Z)</h3>
            <div id="or-obj-inputs" class="input-row"></div>
            <h3>Constraints (Subject to)</h3>
            <div id="or-constraint-inputs"></div>
            <button onclick="solveOR()">Solve</button>
        </div>

        <div id="or-output-area"></div>
    </div>

    <!-- FOOTER -->
    <div class="contact-footer">
        <p>:(Contact Me) للتواصل</p>
        <a href="https://wa.me/201554531921" target="_blank" title="Chat on WhatsApp">
            <img src="https://i.ibb.co/VZvZ88M/1000653468.png" alt="WhatsApp">
        </a>
    </div>

    <div class="stats-box">
        <div style="margin-bottom: 4px;">Visits: <span id="visit-count">...</span></div>
        <div>Solved: <span id="solve-count">...</span></div>
    </div>

<script>
        // --- Navigation Logic ---
        function switchTool() {
            const selectedToolId = document.getElementById("tool-menu").value;
            const tools = document.getElementsByClassName("tool-content");
            for (let i = 0; i < tools.length; i++) {
                tools[i].classList.remove("active");
            }
            if (selectedToolId) {
                document.getElementById(selectedToolId).classList.add("active");
            }
        }

        // --- MATH LIBRARY (Fraction Class) ---
        class Frac {
            constructor(n, d = 1) {
                if (d === 0) throw new Error("Division by zero");
                this.n = n;
                this.d = d;
                this.simplify();
            }
            simplify() {
                const gcd = (a, b) => b ? gcd(b, a % b) : a;
                const g = gcd(Math.abs(this.n), Math.abs(this.d));
                this.n /= g;
                this.d /= g;
                if (this.d < 0) { this.n = -this.n; this.d = -this.d; }
            }
            add(o) { return new Frac(this.n * o.d + o.n * this.d, this.d * o.d); }
            sub(o) { return new Frac(this.n * o.d - o.n * this.d, this.d * o.d); }
            mul(o) { return new Frac(this.n * o.n, this.d * o.d); }
            div(o) { return new Frac(this.n * o.d, this.d * o.n); }
            lt(o) { return this.n * o.d < o.n * this.d; }
            gt(o) { return this.n * o.d > o.n * this.d; }
            lte(o) { return this.n * o.d <= o.n * this.d; }
            val() { return this.n / this.d; }
            toString() { return this.d === 1 ? `${this.n}` : `${this.n}/${this.d}`; }
        }

        function parseFrac(val) {
            if (val === "" || val === null || val === undefined) return new Frac(0);
            val = val.toString();
            if (val.includes('/')) {
                const p = val.split('/');
                return new Frac(parseInt(p[0]), parseInt(p[1]));
            } 
            return new Frac(parseFloat(val) || 0);
        }

        // --- ANALYTICS ---
        const NAMESPACE = 'simplex-visualizer-unique-id';
        const KEY_VISITS = 'site-visits1';
        const KEY_SOLVED = 'problems-solved1';

        function initStats() {
            const hasVisitedSession = sessionStorage.getItem('hasVisitedSession');
            const visitUrl = hasVisitedSession 
                ? `https://api.counterapi.dev/v1/${NAMESPACE}/${KEY_VISITS}/` 
                : `https://api.counterapi.dev/v1/${NAMESPACE}/${KEY_VISITS}/up`;

            fetch(visitUrl)
                .then(res => res.json())
                .then(data => {
                    document.getElementById('visit-count').innerText = data.count;
                    if (!hasVisitedSession) sessionStorage.setItem('hasVisitedSession', 'true');
                })
                .catch(() => document.getElementById('visit-count').innerText = "-");

            fetch(`https://api.counterapi.dev/v1/${NAMESPACE}/${KEY_SOLVED}/`)
                .then(res => res.json())
                .then(data => document.getElementById('solve-count').innerText = data.count)
                .catch(() => document.getElementById('solve-count').innerText = "-");
        }

        function trackSolve() {
            fetch(`https://api.counterapi.dev/v1/${NAMESPACE}/${KEY_SOLVED}/up`)
                .then(res => res.json())
                .then(data => document.getElementById('solve-count').innerText = data.count)
                .catch(err => {});
        }

        initStats();

        // --- [LP] SIMPLEX LOGIC ---
        let lpNumVars = 0, lpNumConstraints = 0;

        function generateLPInputs() {
            lpNumVars = parseInt(document.getElementById('lp_numVars').value);
            lpNumConstraints = parseInt(document.getElementById('lp_numConstraints').value);
            
            const objDiv = document.getElementById('lp-obj-inputs');
            objDiv.innerHTML = '';
            for (let i = 0; i < lpNumVars; i++) {
                objDiv.innerHTML += `X${i+1}: <input type="number" id="lp_z_${i}" placeholder="0"> `;
            }

            const constDiv = document.getElementById('lp-constraint-inputs');
            constDiv.innerHTML = '';
            for (let i = 0; i < lpNumConstraints; i++) {
                let html = `<div class="input-row"><strong>C${i+1}:</strong> `;
                for (let j = 0; j < lpNumVars; j++) {
                    html += `X${j+1} <input type="number" id="lp_c_${i}_${j}" placeholder="0"> + `;
                }
                html = html.slice(0, -3); 
                html += ` <= <input type="number" id="lp_rhs_${i}" placeholder="0"></div>`;
                constDiv.innerHTML += html;
            }

            document.getElementById('lp-matrix-inputs').style.display = 'block';
            document.getElementById('lp-output-area').innerHTML = '';
        }

        function solveLP() {
            trackSolve();
            const outputDiv = document.getElementById('lp-output-area');
            outputDiv.innerHTML = '';

            let zVars = [];
            for (let i = 0; i < lpNumVars; i++) {
                zVars.push(parseFrac(document.getElementById(`lp_z_${i}`).value));
            }

            let constraintsCo = [];
            let rhs = [];
            let slacksCo = [];
            
            for (let i = 0; i < lpNumConstraints; i++) {
                let row = [];
                for (let j = 0; j < lpNumVars; j++) {
                    row.push(parseFrac(document.getElementById(`lp_c_${i}_${j}`).value));
                }
                constraintsCo.push(row);
                rhs.push(parseFrac(document.getElementById(`lp_rhs_${i}`).value));

                let slackRow = new Array(lpNumConstraints).fill(new Frac(0));
                slackRow[i] = new Frac(1);
                slacksCo.push(slackRow);
            }

            let zSlacks = new Array(lpNumConstraints).fill(new Frac(0));
            let currentZRowVars = zVars.map(v => v.mul(new Frac(-1)));
            let currentZRowSlacks = zSlacks.map(v => new Frac(0));

            let zValue = new Frac(0);
            let basicVarNames = [];
            for (let i = 0; i < lpNumConstraints; i++) {
                basicVarNames.push(`s${i+1}`);
            }

            let augHTML = `<h3>Augmented Form</h3><div style="background:#fff; border:1px solid #ccc; padding:15px; font-family:'Courier New', monospace; margin-bottom:20px; line-height: 1.6;">(0) Z`;
            for(let i=0; i<lpNumVars; i++) {
                let val = currentZRowVars[i];
                augHTML += ` ${val.val() >= 0 ? '+' : ''} ${val}X${i+1}`;
            }
            augHTML += ` = 0<br>`;
            for(let i=0; i<lpNumConstraints; i++) {
                augHTML += `(${i+1}) `;
                for(let j=0; j<lpNumVars; j++) augHTML += ` ${constraintsCo[i][j].val() >= 0 ? '+' : ''} ${constraintsCo[i][j]}X${j+1}`;
                for(let s=0; s<lpNumConstraints; s++) augHTML += ` + ${s===i?'1':'0'}S${s+1}`;
                augHTML += ` = ${rhs[i]}<br>`;
            }
            augHTML += `</div>`;
            outputDiv.innerHTML += augHTML;

            let iteration = 1;
            while (true) {
                if (iteration > 20) { outputDiv.innerHTML += `<p style="color:red">Max iterations reached.</p>`; break; }

                let zRowMini = new Frac(0);
                let enterCol = -1;
                let enteringIsSlack = false;
                let enterSlackIdx = -1;

                for (let i = 0; i < lpNumVars; i++) {
                    if (currentZRowVars[i].lt(zRowMini)) {
                        zRowMini = currentZRowVars[i];
                        enterCol = i;
                        enteringIsSlack = false;
                    }
                }
                for (let i = 0; i < lpNumConstraints; i++) {
                    if (currentZRowSlacks[i].lt(zRowMini)) {
                        zRowMini = currentZRowSlacks[i];
                        enterCol = i; 
                        enteringIsSlack = true;
                        enterSlackIdx = i;
                    }
                }

                if (zRowMini.val() >= -1e-9) {
                     let finalHTML = `<div class="iteration-box" style="border: 2px solid green; background-color: #f0fff0;"><h4 style="color: green;">Final Optimal Tableau</h4><table><tr><th>Basic</th><th>Z</th>`;
                    for(let j=0; j<lpNumVars; j++) finalHTML += `<th>x${j+1}</th>`;
                    for(let j=0; j<lpNumConstraints; j++) finalHTML += `<th>s${j+1}</th>`;
                    finalHTML += `<th>RHS</th></tr><tr><td>Z</td><td>1</td>`;
                    currentZRowVars.forEach(v => finalHTML += `<td>${v}</td>`);
                    currentZRowSlacks.forEach(v => finalHTML += `<td>${v}</td>`);
                    finalHTML += `<td>${zValue}</td></tr>`;
                    for (let i = 0; i < lpNumConstraints; i++) {
                        finalHTML += `<tr><td>${basicVarNames[i]}</td><td>0</td>`;
                        for (let j = 0; j < lpNumVars; j++) finalHTML += `<td>${constraintsCo[i][j]}</td>`;
                        for (let j = 0; j < lpNumConstraints; j++) finalHTML += `<td>${slacksCo[i][j]}</td>`;
                        finalHTML += `<td>${rhs[i]}</td></tr>`;
                    }
                    finalHTML += `</table></div><h3>Optimal Solution Reached</h3><div class="lp-optimal-res">Max Z = ${zValue}</div>`;

                    let finalX = new Array(lpNumVars).fill(new Frac(0));
                    let finalS = new Array(lpNumConstraints).fill(new Frac(0));

                    for(let i=0; i<lpNumConstraints; i++) {
                        let name = basicVarNames[i];
                        if(name.startsWith("x")) {
                            let idx = parseInt(name.substring(1)) - 1;
                            finalX[idx] = rhs[i];
                        } else if(name.startsWith("s")) {
                            let idx = parseInt(name.substring(1)) - 1;
                            finalS[idx] = rhs[i];
                        }
                    }

                    let valHTML = `<div style="background: white; padding: 15px; border-radius: 8px; border: 1px solid #ccc; margin-top: 15px;">`;
                    valHTML += `<h4 style="margin-top:0;">Decision Variables:</h4><p>`;
                    finalX.forEach((v, i) => valHTML += `<b>x${i+1}</b> = ${v}&nbsp;&nbsp;&nbsp;&nbsp; `);
                    valHTML += `</p><h4 style="margin-top:10px;">Slack Variables:</h4><p>`;
                    finalS.forEach((v, i) => valHTML += `<b>s${i+1}</b> = ${v}&nbsp;&nbsp;&nbsp;&nbsp; `);
                    valHTML += `</p></div>`;
                    
                    finalHTML += valHTML;
                    outputDiv.innerHTML += finalHTML;
                    break;
                }

                let leaveRow = -1;
                let minRatio = null;
                let ratios = [];

                for (let i = 0; i < lpNumConstraints; i++) {
                    let coeff = enteringIsSlack ? slacksCo[i][enterSlackIdx] : constraintsCo[i][enterCol];
                    let r = null;
                    if (coeff.val() > 0) {
                        r = rhs[i].div(coeff);
                        if (minRatio === null || r.lt(minRatio)) {
                            minRatio = r;
                            leaveRow = i;
                        }
                    }
                    ratios.push(r);
                }

                if (leaveRow === -1) { outputDiv.innerHTML += `<p style="color:red">Unbounded Solution.</p>`; return; }

                let enteringName = enteringIsSlack ? `s${enterSlackIdx+1}` : `x${enterCol+1}`;
                let leavingName = basicVarNames[leaveRow];

                let tableHTML = `<div class="iteration-box"><h4>Iteration ${iteration}</h4><p>Entering: <b>${enteringName}</b> | Leaving: <b>${leavingName}</b></p><table><tr><th>Basic</th><th>Z</th>`;
                for(let j=0; j<lpNumVars; j++) tableHTML += `<th>x${j+1}</th>`;
                for(let j=0; j<lpNumConstraints; j++) tableHTML += `<th>s${j+1}</th>`;
                tableHTML += `<th>RHS</th><th>Ratio</th></tr>`;

                tableHTML += `<tr><td>Z</td><td>1</td>`;
                currentZRowVars.forEach((v, idx) => {
                    let isPivCol = (!enteringIsSlack && idx === enterCol);
                    tableHTML += `<td class="${isPivCol ? 'lp-pivot-col' : ''}">${v}</td>`;
                });
                currentZRowSlacks.forEach((v, idx) => {
                    let isPivCol = (enteringIsSlack && idx === enterSlackIdx);
                    tableHTML += `<td class="${isPivCol ? 'lp-pivot-col' : ''}">${v}</td>`;
                });
                tableHTML += `<td>${zValue}</td><td>-</td></tr>`;

                for (let i = 0; i < lpNumConstraints; i++) {
                    let isPivRow = (i === leaveRow);
                    tableHTML += `<tr class="${isPivRow ? 'lp-pivot-row' : ''}"><td>${basicVarNames[i]}</td><td>0</td>`;
                    for (let j = 0; j < lpNumVars; j++) {
                        let isPivCol = (!enteringIsSlack && j === enterCol);
                        let isPivEl = (isPivRow && isPivCol);
                        tableHTML += `<td class="${isPivEl ? 'lp-pivot-element' : (isPivCol ? 'lp-pivot-col' : '')}">${constraintsCo[i][j]}</td>`;
                    }
                    for (let j = 0; j < lpNumConstraints; j++) {
                        let isPivCol = (enteringIsSlack && j === enterSlackIdx);
                        let isPivEl = (isPivRow && isPivCol);
                        tableHTML += `<td class="${isPivEl ? 'lp-pivot-element' : (isPivCol ? 'lp-pivot-col' : '')}">${slacksCo[i][j]}</td>`;
                    }
                    tableHTML += `<td>${rhs[i]}</td><td>${ratios[i] !== null ? ratios[i] : '-'}</td></tr>`;
                }
                tableHTML += `</table></div>`;
                outputDiv.innerHTML += tableHTML;

                let pivotElement = enteringIsSlack ? slacksCo[leaveRow][enterSlackIdx] : constraintsCo[leaveRow][enterCol];
                for (let j = 0; j < lpNumVars; j++) constraintsCo[leaveRow][j] = constraintsCo[leaveRow][j].div(pivotElement);
                for (let j = 0; j < lpNumConstraints; j++) slacksCo[leaveRow][j] = slacksCo[leaveRow][j].div(pivotElement);
                rhs[leaveRow] = rhs[leaveRow].div(pivotElement);
                basicVarNames[leaveRow] = enteringName;

                for (let i = 0; i < lpNumConstraints; i++) {
                    if (i !== leaveRow) {
                        let factor = enteringIsSlack ? slacksCo[i][enterSlackIdx] : constraintsCo[i][enterCol];
                        for (let j = 0; j < lpNumVars; j++) constraintsCo[i][j] = constraintsCo[i][j].sub(factor.mul(constraintsCo[leaveRow][j]));
                        for (let j = 0; j < lpNumConstraints; j++) slacksCo[i][j] = slacksCo[i][j].sub(factor.mul(slacksCo[leaveRow][j]));
                        rhs[i] = rhs[i].sub(factor.mul(rhs[leaveRow]));
                    }
                }
                let zFactor = enteringIsSlack ? currentZRowSlacks[enterSlackIdx] : currentZRowVars[enterCol];
                for (let j = 0; j < lpNumVars; j++) currentZRowVars[j] = currentZRowVars[j].sub(zFactor.mul(constraintsCo[leaveRow][j]));
                for (let j = 0; j < lpNumConstraints; j++) currentZRowSlacks[j] = currentZRowSlacks[j].sub(zFactor.mul(slacksCo[leaveRow][j]));
                zValue = zValue.sub(zFactor.mul(rhs[leaveRow]));

                iteration++;
            }
        }

        // --- [OR] SIMPLEX LOGIC ---
        let orNumVars = 0, orNumConstraints = 0;

        function generateORInputs() {
            orNumVars = parseInt(document.getElementById('or_numVars').value);
            orNumConstraints = parseInt(document.getElementById('or_numConstraints').value);
            
            const objContainer = document.getElementById('or-obj-inputs');
            objContainer.innerHTML = 'Maximize Z = ';
            for (let i = 0; i < orNumVars; i++) {
                objContainer.innerHTML += `<input type="number" id="or_z_${i}" placeholder="0"> X${i+1} + `;
            }
            objContainer.innerHTML = objContainer.innerHTML.slice(0, -3);

            const constContainer = document.getElementById('or-constraint-inputs');
            constContainer.innerHTML = '';
            for (let i = 0; i < orNumConstraints; i++) {
                let html = `<div class="input-row">`;
                for (let j = 0; j < orNumVars; j++) {
                    html += `<input type="number" id="or_c_${i}_${j}" placeholder="0"> X${j+1} + `;
                }
                html = html.slice(0, -3); 
                html += ` <= <input type="number" id="or_rhs_${i}" placeholder="0"></div>`;
                constContainer.innerHTML += html;
            }

            document.getElementById('or-matrix-inputs').style.display = 'block';
            document.getElementById('or-output-area').innerHTML = '';
        }

        function solveOR() {
            trackSolve();
            const output = document.getElementById('or-output-area');
            output.innerHTML = "";

            let cj_array = []; 
            for(let i=0; i<orNumVars; i++) cj_array.push(parseFrac(document.getElementById(`or_z_${i}`).value));
            for(let i=0; i<orNumConstraints; i++) cj_array.push(new Frac(0)); 

            let rows = []; 
            let basicVarsIndices = []; 
            let rhs = [];

            for(let i=0; i<orNumConstraints; i++) {
                let row = [];
                for(let j=0; j<orNumVars; j++) row.push(parseFrac(document.getElementById(`or_c_${i}_${j}`).value));
                for(let s=0; s<orNumConstraints; s++) row.push(new Frac(s===i ? 1 : 0));
                rows.push(row);
                rhs.push(parseFrac(document.getElementById(`or_rhs_${i}`).value));
                basicVarsIndices.push(orNumVars + i); 
            }

            let standardFormHTML = `<div class="standard-form-box"><h3>Standard Form</h3>`;
            standardFormHTML += `<p>maximize Z = `;
            for(let i=0; i<orNumVars; i++) {
                let val = cj_array[i];
                let str = val.toString();
                if(str === '1') str = '';
                else if(str === '-1') str = '-';
                standardFormHTML += `${str}x${i+1} + `;
            }
            for(let i=0; i<orNumConstraints; i++) standardFormHTML += `0s${i+1} ${i < orNumConstraints-1 ? '+ ' : ''}`;
            standardFormHTML += `</p><p>subject to</p>`;
            
            for(let i=0; i<orNumConstraints; i++) {
                standardFormHTML += `<p>`;
                for(let j=0; j<orNumVars; j++) {
                    let val = rows[i][j];
                    let str = val.toString();
                    if(str === '1') str = '';
                    else if(str === '-1') str = '-';
                    standardFormHTML += `${str}x${j+1} + `;
                }
                for(let s=0; s<orNumConstraints; s++) {
                    if(rows[i][orNumVars+s].val() !== 0) standardFormHTML += `s${s+1}`;
                }
                standardFormHTML += ` = ${rhs[i]}</p>`;
            }
            standardFormHTML += `<p>`;
            for(let i=0; i<orNumVars; i++) standardFormHTML += `x${i+1}, `;
            for(let i=0; i<orNumConstraints; i++) standardFormHTML += `s${i+1}${i < orNumConstraints-1 ? ', ' : ''}`;
            standardFormHTML += ` ≥ 0</p></div>`;
            output.innerHTML += standardFormHTML;

            let iter = 1;
            while(iter <= 20) {
                let zj = [];
                let cj_zj = []; 
                let totalCols = orNumVars + orNumConstraints;

                for(let c=0; c<totalCols; c++) {
                    let sum = new Frac(0);
                    for(let r=0; r<orNumConstraints; r++) {
                        let basicVarIdx = basicVarsIndices[r];
                        let cb = cj_array[basicVarIdx]; 
                        sum = sum.add(cb.mul(rows[r][c]));
                    }
                    zj.push(sum);
                    cj_zj.push(cj_array[c].sub(sum));
                }

                let zValue = new Frac(0);
                for(let r=0; r<orNumConstraints; r++) {
                    let basicVarIdx = basicVarsIndices[r];
                    zValue = zValue.add(cj_array[basicVarIdx].mul(rhs[r]));
                }

                let maxNet = new Frac(-100000); 
                let pivotCol = -1;
                for(let c=0; c<totalCols; c++) {
                    if(cj_zj[c].gt(maxNet)) {
                        maxNet = cj_zj[c];
                        pivotCol = c;
                    }
                }

                let isOptimal = maxNet.lte(new Frac(0)); 

                let ratios = [];
                let pivotRow = -1;
                let minRatio = null;

                if (!isOptimal) {
                    for(let r=0; r<orNumConstraints; r++) {
                        let val = rows[r][pivotCol];
                        if(val.val() > 0) {
                            let ratio = rhs[r].div(val);
                            ratios.push(ratio);
                            if(minRatio === null || ratio.lt(minRatio)) {
                                minRatio = ratio;
                                pivotRow = r;
                            }
                        } else {
                            ratios.push(null);
                        }
                    }
                }

                let enteringName = (!isOptimal && pivotCol !== -1) ? (pivotCol < orNumVars ? `x${pivotCol+1}` : `s${pivotCol-orNumVars+1}`) : "-";
                let leavingName = (!isOptimal && pivotRow !== -1) ? (basicVarsIndices[pivotRow] < orNumVars ? `x${basicVarsIndices[pivotRow]+1}` : `s${basicVarsIndices[pivotRow]-orNumVars+1}`) : "-";

                let html = `<div class="iteration-box"><div class="iteration-title"><h3>Tableau ${iter}</h3></div>`;
                
                if (!isOptimal) {
                    html += `<div class="or-iter-info">Entering Variable: <b>${enteringName}</b> | Leaving Variable: <b>${leavingName}</b></div>`;
                }

                html += `<table class="or-table">
                    <thead>
                        <tr class="top-cj-row">
                            <th colspan="3"></th>`;
                        for(let c=0; c<totalCols; c++) html += `<th>${cj_array[c]}</th>`;
                html += `<th></th></tr>
                        <tr class="header-row">
                            <th></th>
                            <th>Basic Variables</th>
                            <th>Quantity</th>`;
                for(let i=0; i<orNumVars; i++) html += `<th>x${i+1}</th>`;
                for(let i=0; i<orNumConstraints; i++) html += `<th>s${i+1}</th>`;
                html += `<th>Ratio</th>
                        </tr>
                    </thead>
                    <tbody>`;

                for(let r=0; r<orNumConstraints; r++) {
                    let bIdx = basicVarsIndices[r];
                    let bName = bIdx < orNumVars ? `x${bIdx+1}` : `s${bIdx-orNumVars+1}`;
                    let isPivRow = (r === pivotRow && !isOptimal);
                    
                    html += `<tr class="${isPivRow ? 'or-pivot-row' : ''}">`;
                    html += `<td>${cj_array[bIdx]}</td><td>${bName}</td><td>${rhs[r]}</td>`;
                    
                    for(let c=0; c<totalCols; c++) {
                        let isPivCol = (c === pivotCol && !isOptimal);
                        let isPivElem = (isPivRow && isPivCol);
                        html += `<td class="${isPivElem ? 'or-pivot-element' : (isPivCol ? 'or-pivot-col' : '')}">${rows[r][c]}</td>`;
                    }
                    
                    let ratStr = (ratios[r] !== undefined && ratios[r] !== null) ? ratios[r].toString() : "-";
                    html += `<td>${ratStr}</td></tr>`;
                }

                html += `<tr class="or-bottom-row">
                            <td></td>
                            <td class="or-zj-label">Zj</td>
                            <td>${zValue}</td>`;
                for(let c=0; c<totalCols; c++) html += `<td>${zj[c]}</td>`;
                html += `<td></td></tr>`;

                html += `<tr class="or-bottom-row">
                            <td></td>
                            <td class="or-cjzj-label">Cj - Zj</td>
                            <td></td>`;
                for(let c=0; c<totalCols; c++) html += `<td>${cj_zj[c]}</td>`;
                html += `<td></td></tr></tbody></table></div>`;

                output.innerHTML += html;

                if (isOptimal) {
                    output.innerHTML += `<h3 style="color:green; text-align:center;">Optimal Solution Reached! Max Profit Z = ${zValue}</h3>`;
                    
                    let resBox = `<div style="background: #e0f7fa; padding: 20px; border-radius: 8px; border: 2px solid #00acc1; margin-top: 20px;">`;
                    
                    let xStr = "";
                    for(let i=0; i<orNumVars; i++) {
                        let val = new Frac(0);
                        for(let r=0; r<orNumConstraints; r++) {
                            if(basicVarsIndices[r] === i) val = rhs[r];
                        }
                        xStr += `<b>x${i+1}</b> = ${val} &nbsp;&nbsp; `;
                    }
                    resBox += `<p style="font-size: 16px; margin-bottom: 10px; color: #006064;"><strong>Decision Variables:</strong><br> ${xStr}</p>`;

                    let sStr = "";
                    for(let i=0; i<orNumConstraints; i++) {
                        let val = new Frac(0);
                        let globalIdx = orNumVars + i; 
                        for(let r=0; r<orNumConstraints; r++) {
                            if(basicVarsIndices[r] === globalIdx) val = rhs[r];
                        }
                        sStr += `<b>s${i+1}</b> = ${val} &nbsp;&nbsp; `;
                    }
                    resBox += `<hr style="border-top: 1px solid #b2ebf2;"><p style="font-size: 16px; margin-top: 10px; color: #006064;"><strong>Slack Variables:</strong><br> ${sStr}</p>`;
                    
                    resBox += `</div>`;
                    output.innerHTML += resBox;
                    return;
                }

                if (pivotRow === -1) {
                    output.innerHTML += `<h3 style="color:red">Problem is Unbounded</h3>`;
                    return;
                }

                let pivVal = rows[pivotRow][pivotCol];
                for(let c=0; c<totalCols; c++) rows[pivotRow][c] = rows[pivotRow][c].div(pivVal);
                rhs[pivotRow] = rhs[pivotRow].div(pivVal);
                basicVarsIndices[pivotRow] = pivotCol;

                for(let r=0; r<orNumConstraints; r++) {
                    if(r !== pivotRow) {
                        let factor = rows[r][pivotCol];
                        for(let c=0; c<totalCols; c++) rows[r][c] = rows[r][c].sub(factor.mul(rows[pivotRow][c]));
                        rhs[r] = rhs[r].sub(factor.mul(rhs[pivotRow]));
                    }
                }

                iter++;
            }
        }

        // ==========================================
        // FORECASTING TOOL LOGIC
        // ==========================================

        let fc_is_seasonal = false;
        let fc_season_count = 1;

        // UI Helpers
        function toggleSeasonalInput() {
            const chk = document.getElementById('fc_isSeasonal');
            document.getElementById('fc_season_config').style.display = chk.checked ? 'inline' : 'none';
            const saMethod = document.getElementById('fc_method_sa');
            if(chk.checked) {
                saMethod.disabled = false;
                saMethod.checked = true;
                saMethod.parentNode.style.color = 'black';
            } else {
                saMethod.disabled = true;
                saMethod.checked = false;
                saMethod.parentNode.style.color = '#ccc';
            }
        }

        function toggleDateInput() {
            const units = document.getElementsByName('fc_timeUnit');
            let val = 'generic';
            for(let u of units) if(u.checked) val = u.value;
            
            document.getElementById('fc_start_year_span').style.display = (val === 'years') ? 'inline' : 'none';
            document.getElementById('fc_start_month_span').style.display = (val === 'months') ? 'inline' : 'none';
        }

        function toggleAllFC(source, className) {
            const checkboxes = document.querySelectorAll('.' + className);
            for(let i=0; i<checkboxes.length; i++) {
                if(!checkboxes[i].disabled) checkboxes[i].checked = source.checked;
            }
        }

        // Formatting Value based on User Preference
        function fmtFC(num) {
            if (num === null || num === undefined) return "-";
            const useFrac = document.getElementById('fc_use_frac').checked;
            
            if (useFrac) {
                // Try to convert to fraction
                try {
                    // Handle float to approx fraction for display
                    if (Number.isInteger(num)) return num.toString();
                    let f = new Frac(Math.round(num * 1000), 1000); // approx precision
                    f.simplify();
                    return f.toString();
                } catch(e) { return num.toFixed(2); }
            } else {
                return parseFloat(num).toFixed(2);
            }
        }

        function generateForecastingTable() {
            const rows = parseInt(document.getElementById('fc_numPeriods').value);
            fc_is_seasonal = document.getElementById('fc_isSeasonal').checked;
            fc_season_count = fc_is_seasonal ? parseInt(document.getElementById('fc_seasonParts').value) : 1;

            // Generate Time Labels
            let timeLabels = [];
            const unit = document.querySelector('input[name="fc_timeUnit"]:checked').value;
            
            if (unit === 'generic') {
                for(let i=0; i<rows; i++) timeLabels.push("-");
            } else if (unit === 'years') {
                let startYear = parseInt(document.getElementById('fc_startYear').value) || 2020;
                for(let i=0; i<rows; i++) timeLabels.push(startYear + i);
            } else if (unit === 'months') {
                const months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
                let startM = parseInt(document.getElementById('fc_startMonth').value);
                for(let i=0; i<rows; i++) {
                    timeLabels.push(months[(startM + i) % 12]);
                }
            }

            let html = `<table id="fc_input_table"><thead><tr>
                <th style="background:#e9ecef; width:50px;">#</th>`;
            
            if (unit !== 'generic') {
                html += `<th style="background:#e9ecef;">Time (${unit})</th>`;
            }
            
            if (fc_is_seasonal) {
                for(let j=1; j<=fc_season_count; j++) html += `<th>Season ${j}</th>`;
                html += `<th style="background:#f0f0f0; color:#555;">Total (Calc)</th>`;
            } else {
                html += `<th>Data (Demand)</th>`;
            }
            html += `</tr></thead><tbody>`;

            for(let i=0; i<rows; i++) {
                html += `<tr>`;
                html += `<td>${i+1}</td>`; // Serial 1..n
                
                if (unit !== 'generic') {
                    html += `<td><input type="text" value="${timeLabels[i]}" readonly style="background:#f9f9f9; border:none; text-align:center;"></td>`;
                }

                if (fc_is_seasonal) {
                    for(let j=0; j<fc_season_count; j++) {
                        html += `<td><input type="number" id="fc_d_${i}_${j}" class="fc-data-input" oninput="fcUpdateRowTotal(${i})" placeholder="0"></td>`;
                    }
                    html += `<td id="fc_total_${i}" style="font-weight:bold; color:#28a745;">0</td>`;
                } else {
                    html += `<td><input type="number" id="fc_d_${i}" class="fc-data-input" placeholder="0"></td>`;
                }
                html += `</tr>`;
            }
            html += `</tbody></table>`;

            document.getElementById('fc-table-container').innerHTML = html;
            document.getElementById('fc-data-section').style.display = 'block';
            document.getElementById('fc-output-area').innerHTML = '';
        }

        function fcUpdateRowTotal(rowIdx) {
            let sum = 0;
            for(let j=0; j<fc_season_count; j++) {
                let v = parseFloat(document.getElementById(`fc_d_${rowIdx}_${j}`).value) || 0;
                sum += v;
            }
            // Fix: Round to 2 decimal places to prevent floating point errors
            document.getElementById(`fc_total_${rowIdx}`).innerText = parseFloat(sum.toFixed(2));
        }

        // --- Data Extraction ---
        function getFCData() {
            let periods = [];
            let timeLabels = [];
            let demands = [];
            let seasonalData = [];
            const unit = document.querySelector('input[name="fc_timeUnit"]:checked').value;
            const hasTimeCol = (unit !== 'generic');

            const table = document.getElementById('fc_input_table');
            const rows = table.querySelectorAll('tbody tr');

            rows.forEach((tr, idx) => {
                periods.push(idx + 1); // 1-based index
                
                // If time col exists, it's cell 1, else generic
                if (hasTimeCol) {
                    timeLabels.push(tr.cells[1].querySelector('input').value);
                } else {
                    timeLabels.push((idx+1).toString());
                }

                if(fc_is_seasonal) {
                    let sRow = [];
                    let total = 0;
                    for(let j=0; j<fc_season_count; j++) {
                        let val = parseFloat(document.getElementById(`fc_d_${idx}_${j}`).value) || 0;
                        sRow.push(val);
                        total += val;
                    }
                    seasonalData.push(sRow);
                    demands.push(total);
                } else {
                    let input = tr.querySelector('.fc-data-input');
                    let val = parseFloat(input ? input.value : 0) || 0;
                    demands.push(val);
                }
            });

            return { periods, timeLabels, demands, seasonalData, unit };
        }

        // --- MAIN SOLVER ---
        function solveForecasting() {
            trackSolve();

            // 1. Capture Inputs (Persistence)
            const getVal = (id, def) => { const el = document.getElementById(id); return el ? parseFloat(el.value) : def; }
            
            let config = {
                ma_n: getVal('fc_param_ma_n', 3),
                wma_n: getVal('fc_param_wma_n', 3),
                wma_weights: [],
                ses_alpha: getVal('fc_ses_alpha', 0.3),
                aes_alpha: getVal('fc_aes_alpha', 0.5),
                aes_beta: getVal('fc_aes_beta', 0.3)
            };

            // Capture WMA Weights specifically
            if(document.getElementById('fc_param_wma_n')) {
                for(let k=0; k<config.wma_n; k++) {
                    let wEl = document.getElementById(`fc_wma_w_${k}`);
                    if(wEl) config.wma_weights.push(parseFloat(wEl.value));
                }
            }

            const out = document.getElementById('fc-output-area');
            out.innerHTML = "";
            
            const dataObj = getFCData();
            const methods = Array.from(document.querySelectorAll('.fc_method:checked')).map(c => c.value);
            const accs = Array.from(document.querySelectorAll('.fc_acc:checked')).map(c => c.value);
            const xName = document.getElementById('fc_header_x').value || "Period";
            const yName = document.getElementById('fc_header_y').value || "Demand";

            if (methods.length === 0) {
                out.innerHTML = "<p style='color:red;'>Please select at least one method.</p>";
                return;
            }

            if(methods.includes("MA")) renderMA(out, dataObj, accs, xName, yName, config);
            if(methods.includes("WMA")) renderWMA(out, dataObj, accs, xName, yName, config);
            if(methods.includes("SES")) renderSES(out, dataObj, accs, xName, yName, config);
            if(methods.includes("AES")) renderAES(out, dataObj, accs, xName, yName, config);

            let ltlResult = null;
            if(methods.includes("LTL") || methods.includes("SA")) {
                 ltlResult = solveLTLLogic(dataObj.demands);
            }
            if(methods.includes("LTL")) renderLTL(out, dataObj, accs, xName, yName, ltlResult);
            if(methods.includes("SA") && fc_is_seasonal) renderSA(out, dataObj, accs, xName, yName, ltlResult);
        }

        // ==========================================
        // RENDERERS
        // ==========================================

function buildDetailedAccTable(actuals, forecasts, accs, methodTitle) {
            if(accs.length === 0) return "";
            
            // --- 1. Calculate Sums & Counts based on Lecture Logic ---
            let sumDemand = 0;  // Sum of D (only for valid error periods)
            let sumErr = 0;     // Sum of (D-F)
            let sumAbsErr = 0;  // Sum of |D-F|
            let n = 0;          // Count of valid periods (where error != 0)

            // We need to store row data to generate the HTML
            let rowData = [];

            for(let i=0; i<actuals.length; i++) {
                let D = actuals[i];
                let F = forecasts[i];
                let rowObj = { i: i+1, D: D, F: F, isVal: false, e: 0, absE: 0 };

                if(F !== null) {
                    let e = D - F;
                    // Lecture Logic: We only evaluate accuracy where there is an actual error (deviation).
                    // This excludes the initialization period (e.g., F1=D1 => Error=0).
                    // We check if absolute error is significantly > 0 (dealing with float precision)
                    if(Math.abs(e) > 0.0000001) {
                        n++;
                        sumDemand += D;
                        sumErr += e;
                        sumAbsErr += Math.abs(e);
                        
                        rowObj.isVal = true;
                        rowObj.e = e;
                        rowObj.absE = Math.abs(e);
                    }
                }
                rowData.push(rowObj);
            }

            // --- 2. Build HTML Table ---
            let colSpan = 3; // Period, Actual, Forecast
            let html = `<div style="margin-top:15px; border: 2px solid #333; border-radius: 4px; overflow: hidden; font-family: 'Segoe UI', sans-serif;">
                <div style="background:#e0e0e0; padding:10px; font-weight:bold; border-bottom:1px solid #999; text-align:center;">
                    Accuracy Analysis: ${methodTitle}
                </div>
                <table style="font-size:14px; margin:0; width:100%; border-collapse: collapse;">
                <thead>
                    <tr style="background:#f0f0f0; border-bottom: 2px solid #ccc;">
                        <th style="padding:8px; border-right:1px solid #ddd;">Period</th>
                        <th style="padding:8px; border-right:1px solid #ddd;">Actual (D)</th>
                        <th style="padding:8px; border-right:1px solid #ddd;">Forecast (F)</th>`;
            
            // Add Headers based on selection
            if(accs.includes("E") || accs.includes("EBAR")) { html += `<th style="padding:8px; border-right:1px solid #ddd;">Error (e)</th>`; colSpan++; }
            if(accs.includes("MAD")) { html += `<th style="padding:8px; border-right:1px solid #ddd;">|e|</th>`; colSpan++; }
            // Note: For MAPD logic in lecture (Slide 51), we usually don't show a per-row % column, 
            // but we can show it or just use the totals. Let's keep it clean or show |e|/D if needed?
            // User request implies summary is key. Let's stick to standard columns.
            
            html += `</tr></thead><tbody>`;

            // Data Rows
            rowData.forEach(row => {
                let bg = row.isVal ? "#fff" : "#f9f9f9"; // Grey out excluded rows
                html += `<tr style="background:${bg}; border-bottom:1px solid #eee;">
                    <td style="padding:6px; text-align:center; border-right:1px solid #eee;">${row.i}</td>
                    <td style="padding:6px; text-align:center; border-right:1px solid #eee;">${fmtFC(row.D)}</td>
                    <td style="padding:6px; text-align:center; border-right:1px solid #eee;">${row.F !== null ? fmtFC(row.F) : "-"}</td>`;

                if(row.isVal) {
                    if(accs.includes("E") || accs.includes("EBAR")) 
                        html += `<td style="padding:6px; text-align:center; color:${row.e<0?'red':'green'}; border-right:1px solid #eee;">${fmtFC(row.e)}</td>`;
                    if(accs.includes("MAD")) 
                        html += `<td style="padding:6px; text-align:center; border-right:1px solid #eee;">${fmtFC(row.absE)}</td>`;
                } else {
                    // Empty cells for excluded/null rows
                    if(accs.includes("E") || accs.includes("EBAR")) html += `<td style="border-right:1px solid #eee;">-</td>`;
                    if(accs.includes("MAD")) html += `<td style="border-right:1px solid #eee;">-</td>`;
                }
                html += `</tr>`;
            });

            // --- 3. Summary Rows (The Request) ---
            
            // Row A: Sums
            html += `<tr style="background:#fff3e0; font-weight:bold; border-top:2px solid #aaa;">
                <td colspan="1" style="text-align:right; padding:8px;">Total (n=${n}):</td>
                <td style="text-align:center; padding:8px; border-right:1px solid #ccc; color:#000;">${fmtFC(sumDemand)}</td>
                <td style="border-right:1px solid #ccc;"></td>`;
            
            if(accs.includes("E") || accs.includes("EBAR")) html += `<td style="text-align:center; padding:8px; border-right:1px solid #ccc;">${fmtFC(sumErr)}</td>`;
            if(accs.includes("MAD")) html += `<td style="text-align:center; padding:8px; border-right:1px solid #ccc;">${fmtFC(sumAbsErr)}</td>`;
            html += `</tr>`;

            // Row B: Substitution / Formulas
            html += `<tr style="background:#e8f5e9; border-top:1px solid #ccc;">
                <td colspan="3" style="text-align:right; padding:8px; font-style:italic;">Formula Subst.:</td>`;

            if(accs.includes("E") || accs.includes("EBAR")) {
                let txt = "";
                if(accs.includes("EBAR")) txt = `${fmtFC(sumErr)} / ${n}`;
                html += `<td style="text-align:center; padding:8px; border-right:1px solid #ccc; font-family:monospace;">${txt}</td>`;
            }
            if(accs.includes("MAD")) {
                html += `<td style="text-align:center; padding:8px; border-right:1px solid #ccc; font-family:monospace;">${fmtFC(sumAbsErr)} / ${n}</td>`;
            }
            html += `</tr>`;

            // Row C: Final Results
            html += `<tr style="background:#28a745; color:white; font-weight:bold; border-top:1px solid #ccc;">
                <td colspan="3" style="text-align:right; padding:8px;">Final Results:</td>`;

            if(accs.includes("E") || accs.includes("EBAR")) {
                let res = "";
                if(accs.includes("E")) res += `E=${fmtFC(sumErr)}`;
                if(accs.includes("E") && accs.includes("EBAR")) res += `<br>`;
                if(accs.includes("EBAR")) res += `Bias=${fmtFC(sumErr/n)}`;
                html += `<td style="text-align:center; padding:8px; border-right:1px solid #ccc;">${res}</td>`;
            }
            if(accs.includes("MAD")) {
                html += `<td style="text-align:center; padding:8px; border-right:1px solid #ccc;">MAD = ${fmtFC(sumAbsErr/n)}</td>`;
            }
            html += `</tr>`;

            // Special Row for MAPD (Since it uses Demand Sum, not usually a column in the table)
            if(accs.includes("MAPD")) {
                let mapdVal = (sumAbsErr / sumDemand) * 100; // Slide 51 Formula
                html += `<tr style="background:#e3f2fd; border-top:2px solid #aaa;">
                    <td colspan="${colSpan}" style="padding:10px; text-align:center;">
                        <strong>MAPD (MAPE) Calculation:</strong><br>
                        Formula: &sum;|e| / &sum;D <br>
                        Substitution: ${fmtFC(sumAbsErr)} / ${fmtFC(sumDemand)} <br>
                        Result: <strong>${fmtFC(mapdVal)}%</strong>
                    </td>
                </tr>`;
            }

            html += `</tbody></table></div>`;
            return html;
        }

        // --- 1. Moving Average ---
        function renderMA(container, data, accs, xName, yName, config) {
            let n = config.ma_n; 
            // Constraint: n cannot be > total periods for historical check, but we allow it for next period forecast logic.
            
            let forecasts = Array(data.demands.length).fill(null);
            for(let i = n; i < data.demands.length; i++) {
                 // F_t (Forecast for period t, index i) uses demands i-n to i-1
                 let sum = 0;
                 for(let k=1; k<=n; k++) sum += data.demands[i-k];
                 forecasts[i] = sum/n;
            }
            // Next Period
            let nextSum = 0;
            for(let k=1; k<=n; k++) {
                if(data.demands.length-k >= 0) nextSum += data.demands[data.demands.length-k];
            }
            let nextForecast = nextSum/n;

            let html = `<div class="iteration-box" style="border-left: 5px solid #007bff;">
                <h4>Moving Average (MA)</h4>
                <div style="margin-bottom:10px;">
                    Formula: MA<sub>n</sub> = (&#8721; D<sub>i</sub>) / n <br>
                    Parameter: n = <select id="fc_param_ma_n" onchange="solveForecasting()">`;
            // Allow N up to Total Periods
            for(let i=1; i<=data.demands.length; i++) html += `<option value="${i}" ${i===n?'selected':''}>${i}</option>`;
            html += `</select>
                </div>`;
            
            // Example Calculation
            if(n < data.demands.length) {
                 let exSum = 0; 
                 let exStr = "";
                 for(let k=1; k<=n; k++) { 
                     let val = data.demands[n-k];
                     exSum += val; 
                     exStr += `${val} + `; 
                 }
                 html += `<p style="color:#666; font-size:0.9em;">Example (Forecast for Period ${n+1}): (${exStr.slice(0,-3)}) / ${n} = ${fmtFC(exSum/n)}</p>`;
            }

            html += `<table><thead><tr><th>${xName}</th><th>${yName}</th><th>Forecast (MA)</th></tr></thead><tbody>`;
            for(let i=0; i<data.demands.length; i++) {
                html += `<tr><td>${data.timeLabels[i]}</td><td>${data.demands[i]}</td><td>${fmtFC(forecasts[i])}</td></tr>`;
            }
            html += `<tr style="background:#e6f7ff;"><td>Next</td><td>-</td><td><strong>${fmtFC(nextForecast)}</strong></td></tr>`;
            html += `</tbody></table>`;
            
            html += buildDetailedAccTable(data.demands, forecasts, accs, "Moving Average");
            html += `</div>`;
            container.innerHTML += html;
        }

        // --- 2. Weighted Moving Average ---
        function renderWMA(container, data, accs, xName, yName, config) {
            let n = config.wma_n;
            let weights = config.wma_weights;

            // Initialize weights if empty or mismatched size
            if(weights.length !== n) {
                 weights = [];
                 let rem = 1.0;
                 for(let k=0; k<n-1; k++) { weights.push(Number((rem/2).toFixed(2))); rem -= weights[k]; }
                 weights.push(Number(rem.toFixed(2)));
            }

            // Sum Check
            let wSum = weights.reduce((a,b)=>a+b, 0);
            let wMsg = Math.abs(wSum-1.0)>0.01 ? `<div style="color:red; font-weight:bold;">Warning: Weights sum to ${wSum.toFixed(2)}. They should sum to 1.0</div>` : "";

            let forecasts = Array(data.demands.length).fill(null);
            for(let i=n; i<data.demands.length; i++) {
                let f = 0;
                for(let k=0; k<n; k++) {
                    // weights[0] is most recent. data[i-1] is most recent relative to i.
                    f += weights[k] * data.demands[i-1-k];
                }
                forecasts[i] = f;
            }
            let nextF = 0;
            for(let k=0; k<n; k++) {
                if(data.demands.length-1-k >= 0) nextF += weights[k] * data.demands[data.demands.length-1-k];
            }

            let html = `<div class="iteration-box" style="border-left: 5px solid #6f42c1;">
                <h4>Weighted Moving Average (WMA)</h4>
                ${wMsg}
                <div style="margin-bottom:10px;">
                    Formula: WMA = &#8721; (Weight<sub>i</sub> &times; Demand<sub>t-i</sub>) <br>
                    Parameter n: <select id="fc_param_wma_n" onchange="solveForecasting()" style="margin-right:10px;">`;
            for(let i=1; i<=data.demands.length; i++) html += `<option value="${i}" ${i===n?'selected':''}>${i}</option>`;
            html += `</select> <br><strong>Weights</strong> (Most recent period first):<br>`;
            
            for(let k=0; k<n; k++) {
                html += `W<sub>t-${k+1}</sub>: <input type="number" id="fc_wma_w_${k}" value="${weights[k]}" step="0.01" style="width:60px;" onchange="solveForecasting()"> `;
            }
            html += `</div>`;

            // Table with Weight Explanation
            html += `<table><thead><tr><th>${xName}</th><th>${yName}</th><th>Forecast</th><th>Weights Used</th></tr></thead><tbody>`;
            for(let i=0; i<data.demands.length; i++) {
                let wStr = "-";
                if (forecasts[i] !== null) {
                    wStr = `<span style="font-size:0.8em; color:#666;">`;
                    for(let k=0; k<n; k++) wStr += `(${weights[k]}&times;${data.demands[i-1-k]}) + `;
                    wStr = wStr.slice(0, -3) + "</span>";
                }
                html += `<tr><td>${data.timeLabels[i]}</td><td>${data.demands[i]}</td><td>${fmtFC(forecasts[i])}</td><td>${wStr}</td></tr>`;
            }
            html += `<tr style="background:#f3e5f5;"><td>Next</td><td>-</td><td><strong>${fmtFC(nextF)}</strong></td><td>-</td></tr>`;
            html += `</tbody></table>`;
            html += buildDetailedAccTable(data.demands, forecasts, accs, "Weighted MA");
            html += `</div>`;
            container.innerHTML += html;
        }

        // --- 3. Simple Exponential Smoothing ---
        function renderSES(container, data, accs, xName, yName, config) {
            let alpha = config.ses_alpha;

            let forecasts = [];
            // F1 = D1 (Lecture assumption)
            forecasts.push(data.demands[0]); 
            
            for(let i=1; i<data.demands.length; i++) {
                let val = alpha * data.demands[i-1] + (1-alpha) * forecasts[i-1];
                forecasts.push(val);
            }
            let nextF = alpha * data.demands[data.demands.length-1] + (1-alpha) * forecasts[forecasts.length-1];

            let exHtml = "";
            if(data.demands.length > 1) {
                exHtml = `<p style="color:#666; font-size:0.9em;">Example (Period 2): ${alpha}(${data.demands[0]}) + (1-${alpha})(${data.demands[0]}) = ${fmtFC(forecasts[1])}</p>`;
            }

            let html = `<div class="iteration-box" style="border-left: 5px solid #fd7e14;">
                <h4>Simple Exponential Smoothing</h4>
                Formula: F<sub>t+1</sub> = &alpha;D<sub>t</sub> + (1-&alpha;)F<sub>t</sub> <br>
                Parameter &alpha;: <input type="number" id="fc_ses_alpha" value="${alpha}" step="0.1" min="0" max="1" onchange="solveForecasting()">
                ${exHtml}
                <table><thead><tr><th>${xName}</th><th>${yName}</th><th>Forecast (F<sub>t</sub>)</th></tr></thead><tbody>`;
            
            for(let i=0; i<data.demands.length; i++) {
                 html += `<tr><td>${data.timeLabels[i]}</td><td>${data.demands[i]}</td><td>${fmtFC(forecasts[i])}</td></tr>`;
            }
            html += `<tr style="background:#fff3e0;"><td>Next</td><td>-</td><td><strong>${fmtFC(nextF)}</strong></td></tr>`;
            html += `</tbody></table>`;
            html += buildDetailedAccTable(data.demands, forecasts, accs, "Simple Exp Smoothing");
            html += `</div>`;
            container.innerHTML += html;
        }

        // --- 4. Adjusted Exponential Smoothing ---
        function renderAES(container, data, accs, xName, yName, config) {
            let alpha = config.aes_alpha;
            let beta = config.aes_beta;

            let F = [data.demands[0]]; 
            let T = [0]; 
            let AF = [F[0] + T[0]]; 

            for(let i=1; i<data.demands.length; i++) {
                let ft = alpha * data.demands[i-1] + (1-alpha) * F[i-1]; 
                F.push(ft);
                let tt = beta * (ft - F[i-1]) + (1-beta) * T[i-1];
                T.push(tt);
                AF.push(ft + tt);
            }

            let lastD = data.demands[data.demands.length-1];
            let lastF = F[F.length-1];
            let lastT = T[T.length-1];
            let nextF_simple = alpha * lastD + (1-alpha)*lastF;
            let nextT = beta * (nextF_simple - lastF) + (1-beta)*lastT;
            let nextAF = nextF_simple + nextT;

            let html = `<div class="iteration-box" style="border-left: 5px solid #20c997;">
                <h4>Adjusted Exponential Smoothing</h4>
                Formula: AF<sub>t</sub> = F<sub>t</sub> + T<sub>t</sub> <br>
                &alpha;: <input type="number" id="fc_aes_alpha" value="${alpha}" step="0.1" onchange="solveForecasting()"> 
                &beta;: <input type="number" id="fc_aes_beta" value="${beta}" step="0.1" onchange="solveForecasting()">
                
                <table><thead><tr><th>${xName}</th><th>${yName}</th><th>Forecast (F)</th><th>Trend (T)</th><th>Adj Forecast (AF)</th></tr></thead><tbody>`;
            
            for(let i=0; i<data.demands.length; i++) {
                 html += `<tr><td>${data.timeLabels[i]}</td><td>${data.demands[i]}</td>
                 <td>${fmtFC(F[i])}</td><td>${fmtFC(T[i])}</td><td><strong>${fmtFC(AF[i])}</strong></td></tr>`;
            }
            html += `<tr style="background:#e8f5e9;"><td>Next</td><td>-</td><td>${fmtFC(nextF_simple)}</td><td>${fmtFC(nextT)}</td><td><strong>${fmtFC(nextAF)}</strong></td></tr>`;
            html += `</tbody></table>`;
            html += buildDetailedAccTable(data.demands, AF, accs, "Adjusted Exp Smoothing");
            html += `</div>`;
            container.innerHTML += html;
        }

        // --- 5. Linear Trend Line (Detailed) ---
        function solveLTLLogic(demands) {
            let n = demands.length;
            let sumX=0, sumY=0, sumXY=0, sumX2=0;
            // X is always 1, 2, 3... for LTL calculation regardless of label
            for(let i=0; i<n; i++) {
                let x = i+1;
                let y = demands[i];
                sumX += x;
                sumY += y;
                sumXY += (x*y);
                sumX2 += (x*x);
            }
            let xBar = sumX/n;
            let yBar = sumY/n;
            let b = (sumXY - n*xBar*yBar) / (sumX2 - n*xBar*xBar);
            let a = yBar - b*xBar;
            return { a, b, n, xBar, yBar, sumXY, sumX2, sumX, sumY };
        }

        function renderLTL(container, data, accs, xName, yName, res) {
            let forecasts = [];
            for(let i=0; i<res.n; i++) {
                forecasts.push(res.a + res.b * (i+1));
            }
            let nextF = res.a + res.b * (res.n + 1);

            let html = `<div class="iteration-box" style="border-left: 5px solid #e83e8c;">
                <h4>Linear Trend Line (Least Squares)</h4>
                
                <div style="background:#fff; padding:10px; border:1px solid #ddd; margin-bottom:15px; font-family:'Courier New', monospace;">
                    <h5 style="margin-top:0;">Calculation Table:</h5>
                    <table style="font-size:0.9em;">
                        <thead><tr style="background:#f0f0f0;"><th>Period (x)</th><th>Demand (y)</th><th>xy</th><th>x^2</th></tr></thead>
                        <tbody>`;
            
            // Detailed Rows
            for(let i=0; i<res.n; i++) {
                 let x = i+1;
                 let y = data.demands[i];
                 html += `<tr><td>${x}</td><td>${y}</td><td>${x*y}</td><td>${x*x}</td></tr>`;
            }
            // Sums Row
            html += `<tr style="font-weight:bold; border-top:2px solid #333;">
                <td>&sum;x = ${res.sumX}</td>
                <td>&sum;y = ${res.sumY}</td>
                <td>&sum;xy = ${res.sumXY}</td>
                <td>&sum;x^2 = ${res.sumX2}</td>
            </tr>`;
            html += `</tbody></table>
            
            <h5>Calculations:</h5>
            <p>1. Averages:<br>
               x̄ = ${res.sumX} / ${res.n} = <strong>${fmtFC(res.xBar)}</strong><br>
               ȳ = ${res.sumY} / ${res.n} = <strong>${fmtFC(res.yBar)}</strong>
            </p>
            <p>2. Slope (b):<br>
               b = (&sum;xy - n x̄ ȳ) / (&sum;x^2 - n (x̄)^2)<br>
               b = (${res.sumXY} - ${res.n}(${fmtFC(res.xBar)})(${fmtFC(res.yBar)})) / (${res.sumX2} - ${res.n}(${fmtFC(res.xBar)})^2)<br>
               b = <strong>${fmtFC(res.b)}</strong>
            </p>
            <p>3. Intercept (a):<br>
               a = ȳ - b x̄<br>
               a = ${fmtFC(res.yBar)} - (${fmtFC(res.b)})(${fmtFC(res.xBar)})<br>
               a = <strong>${fmtFC(res.a)}</strong>
            </p>
            <p style="color:blue; font-weight:bold;">Equation: y = ${fmtFC(res.a)} + ${fmtFC(res.b)}x</p>
            </div>

            <table><thead><tr><th>${xName} (x)</th><th>${yName} (y)</th><th>Forecast (y=a+bx)</th></tr></thead><tbody>`;
            
            for(let i=0; i<data.demands.length; i++) {
                 html += `<tr><td>${data.timeLabels[i]}</td><td>${data.demands[i]}</td><td>${fmtFC(forecasts[i])}</td></tr>`;
            }
            html += `<tr style="background:#fce4ec;"><td>Next (x=${res.n+1})</td><td>-</td><td><strong>${fmtFC(nextF)}</strong></td></tr>`;
            html += `</tbody></table>`;
            html += buildDetailedAccTable(data.demands, forecasts, accs, "Linear Trend Line");
            html += `</div>`;
            container.innerHTML += html;
        }

        // --- 6. Seasonal Adjustments ---
        function renderSA(container, data, accs, xName, yName, ltlRes) {
            let seasonSums = Array(fc_season_count).fill(0);
            let grandTotal = 0;
            let rowCount = data.seasonalData.length; 
            
            for(let r=0; r<rowCount; r++) {
                for(let c=0; c<fc_season_count; c++) {
                    let val = data.seasonalData[r][c];
                    seasonSums[c] += val;
                    grandTotal += val;
                }
            }
            
            let indices = [];
            for(let c=0; c<fc_season_count; c++) {
                indices.push(seasonSums[c] / grandTotal);
            }

            let nextYearX = ltlRes.n + 1; 
            let nextYearTotal = ltlRes.a + ltlRes.b * nextYearX;
            
            let seasonalForecasts = indices.map(idx => idx * nextYearTotal);

            let html = `<div class="iteration-box" style="border-left: 5px solid #17a2b8;">
                <h4>Seasonal Adjustments</h4>
                <p><strong>Step 1: Seasonal Indices</strong> (Avg of Season / Grand Avg)<br>`;
            
            indices.forEach((idx, i) => {
                html += `S${i+1}: ${fmtFC(idx)} &nbsp; `;
            });
            html += `</p><p><strong>Step 2: Trend Forecast for Next Year</strong> (Period ${nextYearX})<br>
            Using LTL (y=${fmtFC(ltlRes.a)} + ${fmtFC(ltlRes.b)}x): Total = ${fmtFC(nextYearTotal)}</p>
            
            <p><strong>Step 3: Adjusted Quarterly Forecasts</strong><br>
            SF<sub>i</sub> = Total &times; S<sub>i</sub></p>
            <table style="width:auto;"><thead><tr><th>Season</th><th>Calculation</th><th>Forecast</th></tr></thead><tbody>`;
            
            seasonalForecasts.forEach((sf, i) => {
                html += `<tr><td>Season ${i+1}</td><td>${fmtFC(nextYearTotal)} * ${fmtFC(indices[i])}</td><td><strong>${fmtFC(sf)}</strong></td></tr>`;
            });
            html += `</tbody></table></div>`;
            container.innerHTML += html;
        }
    </script>
</body>
</html>
