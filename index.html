<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplex Method Suite</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 20px; max-width: 1000px; margin: auto; background-color: #f9f9f9; color: #333; }
        h1, h2, h3 { color: #333; text-align: center; }
        
        .tab-container { display: flex; justify-content: center; margin-bottom: 20px; }
        .tab-button { background-color: #ddd; border: none; outline: none; cursor: pointer; padding: 14px 24px; transition: 0.3s; font-size: 17px; font-weight: bold; border-radius: 5px 5px 0 0; margin: 0 2px; }
        .tab-button:hover { background-color: #ccc; }
        .tab-button.active { background-color: #007bff; color: white; }
        
        .tool-content { display: none; padding: 20px; border: 1px solid #ccc; background: white; border-radius: 0 0 5px 5px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .tool-content.active { display: block; }

        .config-section, .input-section { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .input-row { display: flex; align-items: center; margin-bottom: 10px; flex-wrap: wrap; justify-content: center; }
        input[type="number"], input[type="text"] { width: 60px; padding: 5px; margin: 0 5px; border: 1px solid #ccc; border-radius: 4px; text-align: center; }
        
        button { background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-top: 10px; }
        button:hover { background-color: #0056b3; }

        table { border-collapse: collapse; width: 100%; margin: 15px 0; font-size: 14px; background: white; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        
        /* LP Simplex Styles (Original) */
        .lp-pivot-col { background-color: #e6f7ff; }
        .lp-pivot-row { background-color: #fff0f0; }
        .lp-pivot-element { background-color: #ffeb3b; font-weight: bold; border: 2px solid #ff9800; }
        .lp-optimal-res { color: green; font-weight: bold; font-size: 1.2em; }
        
        /* OR Simplex Styles (Lecture Style - Softer) */
        .or-table th { background-color: #f8f9fa; color: #333; font-weight: 600; border-bottom: 2px solid #dee2e6; }
        .or-pivot-col { background-color: #f0fdf4; border-left: 2px solid #86efac; border-right: 2px solid #86efac; }
        .or-pivot-row { background-color: #fff7ed; border-top: 2px solid #fdba74; border-bottom: 2px solid #fdba74; }
        .or-pivot-element { background-color: #fde68a; font-weight: bold; border: 2px solid #f59e0b; color: #451a03; }
        .or-bottom-row td { font-weight: bold; background-color: #fcfcfc; color: #555; }
        .or-iter-info { background-color: #eef2ff; padding: 10px; border-radius: 5px; border-left: 4px solid #6366f1; margin-bottom: 10px; font-weight: 500; }

        .iteration-box { border: 1px solid #ccc; padding: 15px; margin-bottom: 20px; background: white; }

        .contact-footer { text-align: center; margin-top: 40px; margin-bottom: 20px; padding: 10px; }
        .contact-footer p { margin: 0 0 5px 0; font-size: 14px; color: #666; font-weight: 600; }
        .contact-footer img { width: 45px; height: auto; transition: transform 0.2s ease; display: inline-block; }
        .contact-footer img:hover { transform: scale(1.1); opacity: 0.9; }

        .stats-box { position: fixed; bottom: 10px; left: 10px; background: rgba(255, 255, 255, 0.95); padding: 8px 12px; border: 1px solid #ccc; border-radius: 5px; font-family: sans-serif; font-size: 13px; z-index: 1000; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    </style>
</head>
<body>

    <div style="text-align: center; margin: 20px 0;">
        <img src="https://i.ibb.co/C3KMKT9N/photo-2023-07-08-02-41-40-2.jpg" alt="Simplex Logo" style="max-width: 100%; max-height: 250px; height: auto; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
    </div>

    <h1>Simplex Iteration Visualizer</h1>

    <div class="tab-container">
        <button class="tab-button active" onclick="openTab(event, 'lp-simplex')">LP Simplex</button>
        <button class="tab-button" onclick="openTab(event, 'or-simplex')">OR Simplex</button>
    </div>

    <!-- LP SIMPLEX TOOL (Original style, Fractions logic) -->
    <div id="lp-simplex" class="tool-content active">
        <div class="config-section">
            <h3>Configuration</h3>
            <label>Variables: <input type="number" id="lp_numVars" value="2" min="1"></label>
            <label>Constraints: <input type="number" id="lp_numConstraints" value="2" min="1"></label>
            <button onclick="generateLPInputs()">Generate Inputs</button>
        </div>

        <div id="lp-matrix-inputs" class="input-section" style="display:none;">
            <h3>Objective Function (Max Z)</h3>
            <div id="lp-obj-inputs" class="input-row"></div>
            <h3>Constraints (<=)</h3>
            <div id="lp-constraint-inputs"></div>
            <button onclick="solveLP()">Solve</button>
        </div>

        <div id="lp-output-area"></div>
    </div>

    <!-- OR SIMPLEX TOOL (Lecture style) -->
    <div id="or-simplex" class="tool-content">
        <div class="config-section">
            <h3>Configuration</h3>
            <label>Variables: <input type="number" id="or_numVars" value="2" min="1"></label>
            <label>Constraints: <input type="number" id="or_numConstraints" value="2" min="1"></label>
            <button onclick="generateORInputs()">Generate Inputs</button>
        </div>

        <div id="or-matrix-inputs" class="input-section" style="display:none;">
            <h3>Objective Function (Maximize Z)</h3>
            <div id="or-obj-inputs" class="input-row"></div>
            <h3>Constraints (Subject to)</h3>
            <div id="or-constraint-inputs"></div>
            <button onclick="solveOR()">Solve</button>
        </div>

        <div id="or-output-area"></div>
    </div>

    <div class="contact-footer">
        <p>:(Contact Me) للتواصل</p>
        <a href="https://wa.me/201554531921" target="_blank" title="Chat on WhatsApp">
            <img src="https://i.ibb.co/VZvZ88M/1000653468.png" alt="WhatsApp">
        </a>
    </div>

    <div class="stats-box">
        <div style="margin-bottom: 4px;">Visits: <span id="visit-count">...</span></div>
        <div>Solved: <span id="solve-count">...</span></div>
    </div>

    <script>
        class Frac {
            constructor(n, d = 1) {
                if (d === 0) throw new Error("Division by zero");
                this.n = n;
                this.d = d;
                this.simplify();
            }
            simplify() {
                const gcd = (a, b) => b ? gcd(b, a % b) : a;
                const g = gcd(Math.abs(this.n), Math.abs(this.d));
                this.n /= g;
                this.d /= g;
                if (this.d < 0) { this.n = -this.n; this.d = -this.d; }
            }
            add(o) { return new Frac(this.n * o.d + o.n * this.d, this.d * o.d); }
            sub(o) { return new Frac(this.n * o.d - o.n * this.d, this.d * o.d); }
            mul(o) { return new Frac(this.n * o.n, this.d * o.d); }
            div(o) { return new Frac(this.n * o.d, this.d * o.n); }
            lt(o) { return this.n * o.d < o.n * this.d; }
            gt(o) { return this.n * o.d > o.n * this.d; }
            lte(o) { return this.n * o.d <= o.n * this.d; }
            val() { return this.n / this.d; }
            toString() { return this.d === 1 ? `${this.n}` : `${this.n}/${this.d}`; }
        }

        function parseFrac(val) {
            if (val === "" || val === null || val === undefined) return new Frac(0);
            val = val.toString();
            if (val.includes('/')) {
                const p = val.split('/');
                return new Frac(parseInt(p[0]), parseInt(p[1]));
            } 
            return new Frac(parseFloat(val) || 0);
        }

        function openTab(evt, tabName) {
            const contents = document.getElementsByClassName("tool-content");
            for (let i = 0; i < contents.length; i++) contents[i].classList.remove("active");
            const tabs = document.getElementsByClassName("tab-button");
            for (let i = 0; i < tabs.length; i++) tabs[i].classList.remove("active");
            document.getElementById(tabName).classList.add("active");
            evt.currentTarget.classList.add("active");
        }

        const NAMESPACE = 'simplex-visualizer-unique-id';
        const KEY_VISITS = 'site-visits1';
        const KEY_SOLVED = 'problems-solved1';

        function initStats() {
            const hasVisitedSession = sessionStorage.getItem('hasVisitedSession');
            const visitUrl = hasVisitedSession 
                ? `https://api.counterapi.dev/v1/${NAMESPACE}/${KEY_VISITS}/` 
                : `https://api.counterapi.dev/v1/${NAMESPACE}/${KEY_VISITS}/up`;

            fetch(visitUrl)
                .then(res => res.json())
                .then(data => {
                    document.getElementById('visit-count').innerText = data.count;
                    if (!hasVisitedSession) sessionStorage.setItem('hasVisitedSession', 'true');
                })
                .catch(() => document.getElementById('visit-count').innerText = "-");

            fetch(`https://api.counterapi.dev/v1/${NAMESPACE}/${KEY_SOLVED}/`)
                .then(res => res.json())
                .then(data => document.getElementById('solve-count').innerText = data.count)
                .catch(() => document.getElementById('solve-count').innerText = "-");
        }

        function trackSolve() {
            fetch(`https://api.counterapi.dev/v1/${NAMESPACE}/${KEY_SOLVED}/up`)
                .then(res => res.json())
                .then(data => document.getElementById('solve-count').innerText = data.count)
                .catch(err => {});
        }

        initStats();

        // ---------------------------------------------------------
        // LP SIMPLEX LOGIC (ORIGINAL + FRACTIONS)
        // ---------------------------------------------------------
        let lpNumVars = 0, lpNumConstraints = 0;

        function generateLPInputs() {
            lpNumVars = parseInt(document.getElementById('lp_numVars').value);
            lpNumConstraints = parseInt(document.getElementById('lp_numConstraints').value);
            
            const objDiv = document.getElementById('lp-obj-inputs');
            objDiv.innerHTML = '';
            for (let i = 0; i < lpNumVars; i++) {
                objDiv.innerHTML += `X${i+1}: <input type="number" id="lp_z_${i}" placeholder="0"> `;
            }

            const constDiv = document.getElementById('lp-constraint-inputs');
            constDiv.innerHTML = '';
            for (let i = 0; i < lpNumConstraints; i++) {
                let html = `<div class="input-row"><strong>C${i+1}:</strong> `;
                for (let j = 0; j < lpNumVars; j++) {
                    html += `X${j+1} <input type="number" id="lp_c_${i}_${j}" placeholder="0"> + `;
                }
                html = html.slice(0, -3); 
                html += ` <= <input type="number" id="lp_rhs_${i}" placeholder="0"></div>`;
                constDiv.innerHTML += html;
            }

            document.getElementById('lp-matrix-inputs').style.display = 'block';
            document.getElementById('lp-output-area').innerHTML = '';
        }

        function solveLP() {
            trackSolve();
            const outputDiv = document.getElementById('lp-output-area');
            outputDiv.innerHTML = '';

            let zVars = [];
            for (let i = 0; i < lpNumVars; i++) {
                zVars.push(parseFrac(document.getElementById(`lp_z_${i}`).value));
            }

            let constraintsCo = [];
            let rhs = [];
            let slacksCo = [];
            
            for (let i = 0; i < lpNumConstraints; i++) {
                let row = [];
                for (let j = 0; j < lpNumVars; j++) {
                    row.push(parseFrac(document.getElementById(`lp_c_${i}_${j}`).value));
                }
                constraintsCo.push(row);
                rhs.push(parseFrac(document.getElementById(`lp_rhs_${i}`).value));

                let slackRow = new Array(lpNumConstraints).fill(new Frac(0));
                slackRow[i] = new Frac(1);
                slacksCo.push(slackRow);
            }

            let zSlacks = new Array(lpNumConstraints).fill(new Frac(0));
            // Convert Z to minimize logic for the table: coeff * -1
            let currentZRowVars = zVars.map(v => v.mul(new Frac(-1)));
            let currentZRowSlacks = zSlacks.map(v => new Frac(0));

            let zValue = new Frac(0);
            let basicVarNames = [];
            for (let i = 0; i < lpNumConstraints; i++) {
                basicVarNames.push(`s${i+1}`);
            }

            // Augmented Form Display
            let augHTML = `<h3>Augmented Form</h3><div style="background:#fff; border:1px solid #ccc; padding:15px; font-family:'Courier New', monospace; margin-bottom:20px; line-height: 1.6;">(0) Z`;
            for(let i=0; i<lpNumVars; i++) {
                let val = currentZRowVars[i];
                augHTML += ` ${val.val() >= 0 ? '+' : ''} ${val}X${i+1}`;
            }
            augHTML += ` = 0<br>`;
            for(let i=0; i<lpNumConstraints; i++) {
                augHTML += `(${i+1}) `;
                for(let j=0; j<lpNumVars; j++) augHTML += ` ${constraintsCo[i][j].val() >= 0 ? '+' : ''} ${constraintsCo[i][j]}X${j+1}`;
                for(let s=0; s<lpNumConstraints; s++) augHTML += ` + ${s===i?'1':'0'}S${s+1}`;
                augHTML += ` = ${rhs[i]}<br>`;
            }
            augHTML += `</div>`;
            outputDiv.innerHTML += augHTML;

            let iteration = 1;
            while (true) {
                if (iteration > 20) { outputDiv.innerHTML += `<p style="color:red">Max iterations reached.</p>`; break; }

                let zRowMini = new Frac(0);
                let enterCol = -1;
                let enteringIsSlack = false;
                let enterSlackIdx = -1;

                // Find entering variable (most negative in Z row)
                for (let i = 0; i < lpNumVars; i++) {
                    if (currentZRowVars[i].lt(zRowMini)) {
                        zRowMini = currentZRowVars[i];
                        enterCol = i;
                        enteringIsSlack = false;
                    }
                }
                for (let i = 0; i < lpNumConstraints; i++) {
                    if (currentZRowSlacks[i].lt(zRowMini)) {
                        zRowMini = currentZRowSlacks[i];
                        enterCol = i; 
                        enteringIsSlack = true;
                        enterSlackIdx = i;
                    }
                }

                if (zRowMini.val() >= -1e-9) {
                    // Optimal Reached
                    let finalHTML = `<div class="iteration-box" style="border: 2px solid green; background-color: #f0fff0;"><h4 style="color: green;">Final Optimal Tableau</h4><table><tr><th>Basic</th><th>Z</th>`;
                    for(let j=0; j<lpNumVars; j++) finalHTML += `<th>x${j+1}</th>`;
                    for(let j=0; j<lpNumConstraints; j++) finalHTML += `<th>s${j+1}</th>`;
                    finalHTML += `<th>RHS</th></tr><tr><td>Z</td><td>1</td>`;
                    currentZRowVars.forEach(v => finalHTML += `<td>${v}</td>`);
                    currentZRowSlacks.forEach(v => finalHTML += `<td>${v}</td>`);
                    finalHTML += `<td>${zValue}</td></tr>`;
                    for (let i = 0; i < lpNumConstraints; i++) {
                        finalHTML += `<tr><td>${basicVarNames[i]}</td><td>0</td>`;
                        for (let j = 0; j < lpNumVars; j++) finalHTML += `<td>${constraintsCo[i][j]}</td>`;
                        for (let j = 0; j < lpNumConstraints; j++) finalHTML += `<td>${slacksCo[i][j]}</td>`;
                        finalHTML += `<td>${rhs[i]}</td></tr>`;
                    }
                    finalHTML += `</table></div><h3>Optimal Solution Reached</h3><div class="lp-optimal-res">Max Z = ${zValue}</div>`;
                    outputDiv.innerHTML += finalHTML;
                    break;
                }

                let leaveRow = -1;
                let minRatio = null;
                let ratios = [];

                for (let i = 0; i < lpNumConstraints; i++) {
                    let coeff = enteringIsSlack ? slacksCo[i][enterSlackIdx] : constraintsCo[i][enterCol];
                    let r = null;
                    if (coeff.val() > 0) {
                        r = rhs[i].div(coeff);
                        if (minRatio === null || r.lt(minRatio)) {
                            minRatio = r;
                            leaveRow = i;
                        }
                    }
                    ratios.push(r);
                }

                if (leaveRow === -1) { outputDiv.innerHTML += `<p style="color:red">Unbounded Solution.</p>`; return; }

                let enteringName = enteringIsSlack ? `s${enterSlackIdx+1}` : `x${enterCol+1}`;
                let leavingName = basicVarNames[leaveRow];

                let tableHTML = `<div class="iteration-box"><h4>Iteration ${iteration}</h4><p>Entering: <b>${enteringName}</b> | Leaving: <b>${leavingName}</b></p><table><tr><th>Basic</th><th>Z</th>`;
                for(let j=0; j<lpNumVars; j++) tableHTML += `<th>x${j+1}</th>`;
                for(let j=0; j<lpNumConstraints; j++) tableHTML += `<th>s${j+1}</th>`;
                tableHTML += `<th>RHS</th><th>Ratio</th></tr>`;

                tableHTML += `<tr><td>Z</td><td>1</td>`;
                currentZRowVars.forEach((v, idx) => {
                    let isPivCol = (!enteringIsSlack && idx === enterCol);
                    tableHTML += `<td class="${isPivCol ? 'lp-pivot-col' : ''}">${v}</td>`;
                });
                currentZRowSlacks.forEach((v, idx) => {
                    let isPivCol = (enteringIsSlack && idx === enterSlackIdx);
                    tableHTML += `<td class="${isPivCol ? 'lp-pivot-col' : ''}">${v}</td>`;
                });
                tableHTML += `<td>${zValue}</td><td>-</td></tr>`;

                for (let i = 0; i < lpNumConstraints; i++) {
                    let isPivRow = (i === leaveRow);
                    tableHTML += `<tr class="${isPivRow ? 'lp-pivot-row' : ''}"><td>${basicVarNames[i]}</td><td>0</td>`;
                    for (let j = 0; j < lpNumVars; j++) {
                        let isPivCol = (!enteringIsSlack && j === enterCol);
                        let isPivEl = (isPivRow && isPivCol);
                        tableHTML += `<td class="${isPivEl ? 'lp-pivot-element' : (isPivCol ? 'lp-pivot-col' : '')}">${constraintsCo[i][j]}</td>`;
                    }
                    for (let j = 0; j < lpNumConstraints; j++) {
                        let isPivCol = (enteringIsSlack && j === enterSlackIdx);
                        let isPivEl = (isPivRow && isPivCol);
                        tableHTML += `<td class="${isPivEl ? 'lp-pivot-element' : (isPivCol ? 'lp-pivot-col' : '')}">${slacksCo[i][j]}</td>`;
                    }
                    tableHTML += `<td>${rhs[i]}</td><td>${ratios[i] !== null ? ratios[i] : '-'}</td></tr>`;
                }
                tableHTML += `</table></div>`;
                outputDiv.innerHTML += tableHTML;

                // Pivot Calculations
                let pivotElement = enteringIsSlack ? slacksCo[leaveRow][enterSlackIdx] : constraintsCo[leaveRow][enterCol];
                for (let j = 0; j < lpNumVars; j++) constraintsCo[leaveRow][j] = constraintsCo[leaveRow][j].div(pivotElement);
                for (let j = 0; j < lpNumConstraints; j++) slacksCo[leaveRow][j] = slacksCo[leaveRow][j].div(pivotElement);
                rhs[leaveRow] = rhs[leaveRow].div(pivotElement);
                basicVarNames[leaveRow] = enteringName;

                for (let i = 0; i < lpNumConstraints; i++) {
                    if (i !== leaveRow) {
                        let factor = enteringIsSlack ? slacksCo[i][enterSlackIdx] : constraintsCo[i][enterCol];
                        for (let j = 0; j < lpNumVars; j++) constraintsCo[i][j] = constraintsCo[i][j].sub(factor.mul(constraintsCo[leaveRow][j]));
                        for (let j = 0; j < lpNumConstraints; j++) slacksCo[i][j] = slacksCo[i][j].sub(factor.mul(slacksCo[leaveRow][j]));
                        rhs[i] = rhs[i].sub(factor.mul(rhs[leaveRow]));
                    }
                }
                let zFactor = enteringIsSlack ? currentZRowSlacks[enterSlackIdx] : currentZRowVars[enterCol];
                for (let j = 0; j < lpNumVars; j++) currentZRowVars[j] = currentZRowVars[j].sub(zFactor.mul(constraintsCo[leaveRow][j]));
                for (let j = 0; j < lpNumConstraints; j++) currentZRowSlacks[j] = currentZRowSlacks[j].sub(zFactor.mul(slacksCo[leaveRow][j]));
                zValue = zValue.sub(zFactor.mul(rhs[leaveRow]));

                iteration++;
            }
        }

        // ---------------------------------------------------------
        // OR SIMPLEX LOGIC (LECTURE STYLE)
        // ---------------------------------------------------------
        let orNumVars = 0, orNumConstraints = 0;

        function generateORInputs() {
            orNumVars = parseInt(document.getElementById('or_numVars').value);
            orNumConstraints = parseInt(document.getElementById('or_numConstraints').value);
            
            const objContainer = document.getElementById('or-obj-inputs');
            objContainer.innerHTML = 'Maximize Z = ';
            for (let i = 0; i < orNumVars; i++) {
                objContainer.innerHTML += `<input type="number" id="or_z_${i}" placeholder="0"> X${i+1} + `;
            }
            objContainer.innerHTML = objContainer.innerHTML.slice(0, -3);

            const constContainer = document.getElementById('or-constraint-inputs');
            constContainer.innerHTML = '';
            for (let i = 0; i < orNumConstraints; i++) {
                let html = `<div class="input-row">`;
                for (let j = 0; j < orNumVars; j++) {
                    html += `<input type="number" id="or_c_${i}_${j}" placeholder="0"> X${j+1} + `;
                }
                html = html.slice(0, -3); 
                html += ` <= <input type="number" id="or_rhs_${i}" placeholder="0"></div>`;
                constContainer.innerHTML += html;
            }

            document.getElementById('or-matrix-inputs').style.display = 'block';
            document.getElementById('or-output-area').innerHTML = '';
        }

        function solveOR() {
            trackSolve();
            const output = document.getElementById('or-output-area');
            output.innerHTML = "";

            let cj_array = []; 
            for(let i=0; i<orNumVars; i++) cj_array.push(parseFrac(document.getElementById(`or_z_${i}`).value));
            for(let i=0; i<orNumConstraints; i++) cj_array.push(new Frac(0)); 

            let rows = []; 
            let basicVarsIndices = []; 
            let rhs = [];

            for(let i=0; i<orNumConstraints; i++) {
                let row = [];
                for(let j=0; j<orNumVars; j++) row.push(parseFrac(document.getElementById(`or_c_${i}_${j}`).value));
                for(let s=0; s<orNumConstraints; s++) row.push(new Frac(s===i ? 1 : 0));
                rows.push(row);
                rhs.push(parseFrac(document.getElementById(`or_rhs_${i}`).value));
                basicVarsIndices.push(orNumVars + i); 
            }

            let iter = 1;
            while(iter <= 20) {
                let zj = [];
                let cj_zj = []; 
                let totalCols = orNumVars + orNumConstraints;

                // Calculate Zj and Cj-Zj
                for(let c=0; c<totalCols; c++) {
                    let sum = new Frac(0);
                    for(let r=0; r<orNumConstraints; r++) {
                        let basicVarIdx = basicVarsIndices[r];
                        let cb = cj_array[basicVarIdx]; 
                        sum = sum.add(cb.mul(rows[r][c]));
                    }
                    zj.push(sum);
                    cj_zj.push(cj_array[c].sub(sum));
                }

                let zValue = new Frac(0);
                for(let r=0; r<orNumConstraints; r++) {
                    let basicVarIdx = basicVarsIndices[r];
                    zValue = zValue.add(cj_array[basicVarIdx].mul(rhs[r]));
                }

                // Determine Entering (Max Positive Cj - Zj)
                let maxNet = new Frac(-100000); 
                let pivotCol = -1;
                for(let c=0; c<totalCols; c++) {
                    if(cj_zj[c].gt(maxNet)) {
                        maxNet = cj_zj[c];
                        pivotCol = c;
                    }
                }

                let isOptimal = maxNet.lte(new Frac(0)); 

                let ratios = [];
                let pivotRow = -1;
                let minRatio = null;

                if (!isOptimal) {
                    for(let r=0; r<orNumConstraints; r++) {
                        let val = rows[r][pivotCol];
                        if(val.val() > 0) {
                            let ratio = rhs[r].div(val);
                            ratios.push(ratio);
                            if(minRatio === null || ratio.lt(minRatio)) {
                                minRatio = ratio;
                                pivotRow = r;
                            }
                        } else {
                            ratios.push(null);
                        }
                    }
                }

                // Build HTML
                let enteringName = (!isOptimal && pivotCol !== -1) ? (pivotCol < orNumVars ? `x${pivotCol+1}` : `s${pivotCol-orNumVars+1}`) : "-";
                let leavingName = (!isOptimal && pivotRow !== -1) ? (basicVarsIndices[pivotRow] < orNumVars ? `x${basicVarsIndices[pivotRow]+1}` : `s${basicVarsIndices[pivotRow]-orNumVars+1}`) : "-";

                let html = `<div class="iteration-box"><div class="iteration-title"><h3>Tableau ${iter}</h3></div>`;
                
                if (!isOptimal) {
                    html += `<div class="or-iter-info">Entering Variable: <b>${enteringName}</b> | Leaving Variable: <b>${leavingName}</b></div>`;
                }

                html += `<table class="or-table">
                    <thead>
                        <tr>
                            <th colspan="3" style="text-align:right;">Cj</th>`;
                        for(let c=0; c<totalCols; c++) html += `<th>${cj_array[c]}</th>`;
                html += `<th></th></tr>
                        <tr>
                            <th>Basic Variables</th>
                            <th>Quantity</th>`;
                for(let i=0; i<orNumVars; i++) html += `<th>x${i+1}</th>`;
                for(let i=0; i<orNumConstraints; i++) html += `<th>s${i+1}</th>`;
                html += `<th>Ratio</th>
                        </tr>
                    </thead>
                    <tbody>`;

                for(let r=0; r<orNumConstraints; r++) {
                    let bIdx = basicVarsIndices[r];
                    let bName = bIdx < orNumVars ? `x${bIdx+1}` : `s${bIdx-orNumVars+1}`;
                    let isPivRow = (r === pivotRow && !isOptimal);
                    
                    html += `<tr class="${isPivRow ? 'or-pivot-row' : ''}">`;
                    html += `<td>${bName}</td><td>${rhs[r]}</td>`;
                    
                    for(let c=0; c<totalCols; c++) {
                        let isPivCol = (c === pivotCol && !isOptimal);
                        let isPivElem = (isPivRow && isPivCol);
                        html += `<td class="${isPivElem ? 'or-pivot-element' : (isPivCol ? 'or-pivot-col' : '')}">${rows[r][c]}</td>`;
                    }
                    
                    let ratStr = (ratios[r] !== undefined && ratios[r] !== null) ? ratios[r].toString() : "-";
                    html += `<td>${ratStr}</td></tr>`;
                }

                // Zj Row
                html += `<tr class="or-bottom-row"><td>Zj</td><td>${zValue}</td>`;
                for(let c=0; c<totalCols; c++) html += `<td>${zj[c]}</td>`;
                html += `<td></td></tr>`;

                // Cj - Zj Row
                html += `<tr class="or-bottom-row"><td>Cj - Zj</td><td></td>`;
                for(let c=0; c<totalCols; c++) html += `<td>${cj_zj[c]}</td>`;
                html += `<td></td></tr></tbody></table></div>`;

                output.innerHTML += html;

                if (isOptimal) {
                    output.innerHTML += `<h3 style="color:green; text-align:center;">Optimal Solution Reached! Max Profit Z = $${zValue}</h3>`;
                    let varsRes = "";
                    for(let i=0; i<orNumVars; i++) {
                        let val = new Frac(0);
                        for(let r=0; r<orNumConstraints; r++) {
                            if(basicVarsIndices[r] === i) val = rhs[r];
                        }
                        varsRes += `x${i+1} = ${val}, `;
                    }
                    output.innerHTML += `<p style="text-align:center;">${varsRes.slice(0, -2)}</p>`;
                    return;
                }

                if (pivotRow === -1) {
                    output.innerHTML += `<h3 style="color:red">Problem is Unbounded</h3>`;
                    return;
                }

                // Math for next iteration
                let pivVal = rows[pivotRow][pivotCol];
                for(let c=0; c<totalCols; c++) rows[pivotRow][c] = rows[pivotRow][c].div(pivVal);
                rhs[pivotRow] = rhs[pivotRow].div(pivVal);
                basicVarsIndices[pivotRow] = pivotCol;

                for(let r=0; r<orNumConstraints; r++) {
                    if(r !== pivotRow) {
                        let factor = rows[r][pivotCol];
                        for(let c=0; c<totalCols; c++) rows[r][c] = rows[r][c].sub(factor.mul(rows[pivotRow][c]));
                        rhs[r] = rhs[r].sub(factor.mul(rhs[pivotRow]));
                    }
                }

                iter++;
            }
        }
    </script>
</body>
</html>
